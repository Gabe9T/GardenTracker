"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const preact_1 = require("preact");
const util_js_1 = require("../../src/util.js");
const PreactShallowRenderer_js_1 = __importDefault(require("./compat-shallow-renderer/PreactShallowRenderer.js"));
const debounce_render_hook_js_1 = require("../../src/debounce-render-hook.js");
const preact10_rst_js_1 = require("../../src/preact10-rst.js");
function isErrorBoundary({ instance, type }) {
    if (typeof type === 'function' &&
        type.getDerivedStateFromError) {
        return true;
    }
    return instance && instance.componentDidCatch;
}
/**
 * A shallow renderer that natively shallow renders Preact components by not
 * relying on a document and overriding children to return null. It relies on a
 * copy of Preact's diff algorithm, modified to not descend and diff children of
 * the given element.
 */
class CompatShallowRenderer {
    constructor() {
        this._renderer = PreactShallowRenderer_js_1.default.createRenderer();
        this._cachedNode = null;
        (0, debounce_render_hook_js_1.installHook)();
    }
    render(el, context, options) {
        this._cachedNode = el;
        if (typeof el.type !== 'string') {
            return this._renderer.render(el, context);
        }
    }
    simulateError(nodeHierarchy, rootNode, error) {
        nodeHierarchy = nodeHierarchy.concat((0, preact10_rst_js_1.rstNodeFromElement)(this._cachedNode));
        const { instance: catchingInstance, type: catchingType } = nodeHierarchy.find(isErrorBoundary) || {};
        const componentDidCatch = catchingInstance?.componentDidCatch;
        const getDerivedStateFromError = catchingType
            ?.getDerivedStateFromError;
        if (!catchingInstance ||
            !catchingType ||
            (!componentDidCatch && !getDerivedStateFromError)) {
            throw error;
        }
        if (getDerivedStateFromError) {
            const stateUpdate = getDerivedStateFromError.call(catchingType, error);
            catchingInstance.setState(stateUpdate);
        }
        if (componentDidCatch) {
            componentDidCatch.call(catchingInstance, error, {
                componentStack: 'Test component stack',
            });
        }
    }
    simulateEvent(node, eventName, args) {
        const handler = node.props[(0, util_js_1.propFromEvent)(eventName)];
        if (handler) {
            handler(args);
        }
    }
    unmount() {
        this._renderer.unmount();
    }
    getNode() {
        if (this._cachedNode == null || !(0, preact_1.isValidElement)(this._cachedNode)) {
            return null;
        }
        (0, debounce_render_hook_js_1.flushRenders)();
        // The output of DOM elements is props.children whereas for components its
        // from the renderer
        const output = typeof this._cachedNode.type === 'string'
            ? this._cachedNode.props.children
            : this._renderer.getRenderOutput();
        return {
            nodeType: (0, preact10_rst_js_1.nodeTypeFromType)(this._cachedNode.type),
            type: this._cachedNode.type,
            props: this._cachedNode.props,
            key: this._cachedNode.key ?? undefined,
            ref: this._cachedNode.ref,
            instance: this._renderer.getMountedInstance(),
            rendered: Array.isArray(output)
                ? output.flat().map(el => (0, preact10_rst_js_1.rstNodeFromElement)(el, true))
                : [(0, preact10_rst_js_1.rstNodeFromElement)(output, true)],
        };
    }
    batchedUpdates(fn) {
        fn();
    }
}
exports.default = CompatShallowRenderer;
