import type { ComponentChild, JSX } from 'preact';
import type { VNode as InternalVNode, ComponentClass, FunctionComponent } from 'preact/src/internal';
import { Component } from 'preact';
interface ClassComponentVNode<P = any> extends InternalVNode<P> {
    type: ComponentClass<P>;
}
interface FunctionComponentVNode<P = any> extends InternalVNode<P> {
    type: FunctionComponent<P>;
}
export declare type ComponentVNode<P = any> = ClassComponentVNode<P> | FunctionComponentVNode<P>;
/**
 * Extend Preact's Component interface with a custom property to indicate this
 * component was shallow rendered. Used by our shallow setState and forceUpdate
 * implementations to rerender components shallowly.
 */
export interface ShallowRenderedComponent<P = any> extends Component<P> {
    _preactShallowRenderer: PreactShallowRenderer;
}
/**
 * This class mirrors ReactShallowRenderer for the purpose of shallow rendering
 * Preact components. It implements the same API and passes almost the exact
 * same test suite
 *
 * https://github.com/enzymejs/react-shallow-renderer
 */
export default class PreactShallowRenderer {
    static createRenderer: () => PreactShallowRenderer;
    /** The current rendering instance of PreactShallowRenderer */
    static current: PreactShallowRenderer | null;
    /**
     * The previous element that was shallowed rendered. It is used to diff an
     * element that gets updated through props or a setState call
     *
     * If render was given a memoed element, this holds the component that was
     * wrapped in memo. It is used if `setState` is called on the component and it
     * needs to be diffed directly.
     */
    private _prevElement;
    /**
     * If render was given a memoed component to render, this is the previous
     * memoed element that will be used if that memoed element is rerendered
     */
    private _memoElement;
    /**
     * The component instance that was shallow rendered. If render was given a
     * memoed element, then this is the instance of the component that was memoed
     */
    private _componentInstance;
    /**
     * The result of the last call to render.
     */
    private _rendered;
    constructor();
    getMountedInstance(): Component<any, any> | null;
    getRenderOutput(): ComponentChild;
    render(element: JSX.Element, context?: any): ComponentChild;
    unmount(): void;
    private _reset;
    private _diffComponent;
}
export {};
