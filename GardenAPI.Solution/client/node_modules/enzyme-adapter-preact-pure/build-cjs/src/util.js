"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.propFromEvent = exports.mapNativeEventNames = exports.nodeToHostNode = exports.isRSTNode = exports.toArray = exports.withReplacedMethod = exports.getDisplayName = exports.nodeType = exports.getType = void 0;
function getType(obj) {
    if (obj == null) {
        return String(obj);
    }
    return obj.constructor.name;
}
exports.getType = getType;
/**
 * Return the type of a vnode as a string.
 */
function nodeType(vnode) {
    if (!vnode.type) {
        return 'null';
    }
    return typeof vnode.type === 'string' ? vnode.type : vnode.type.name;
}
exports.nodeType = nodeType;
function getDisplayName(node) {
    if (node.nodeType === 'host') {
        return node.type;
    }
    else {
        const type = node.type;
        return type.displayName || type.name;
    }
}
exports.getDisplayName = getDisplayName;
/**
 * Call `fn` with a method on an object temporarily replaced with `methodImpl`.
 */
function withReplacedMethod(obj, method, methodImpl, fn) {
    const hadOwnMethod = Object.prototype.hasOwnProperty.call(obj, method);
    const origMethod = obj[method];
    if (typeof origMethod !== 'function') {
        throw new Error(`Expected '${method}' property to be a function`);
    }
    obj[method] = methodImpl;
    try {
        fn();
    }
    finally {
        if (hadOwnMethod) {
            obj[method] = origMethod;
        }
        else {
            delete obj[method];
        }
    }
}
exports.withReplacedMethod = withReplacedMethod;
function toArray(obj) {
    return Array.isArray(obj) ? obj : [obj];
}
exports.toArray = toArray;
function isRSTNode(node) {
    return (node != null &&
        typeof node == 'object' &&
        'nodeType' in node &&
        (node.nodeType === 'host' ||
            node.nodeType === 'class' ||
            node.nodeType === 'function') &&
        'rendered' in node);
}
exports.isRSTNode = isRSTNode;
/**
 * @param node The node to start searching for a host node
 * @returns The first host node in the children of the passed in node. Will
 * return the passed in node if it is a host node
 */
function nodeToHostNode(node) {
    if (!isRSTNode(node)) {
        // Returning `null` here causes `wrapper.text()` to return nothing for a
        // wrapper around a `Text` node. That's not intuitive perhaps, but it
        // matches the React adapters' behaviour.
        return null;
    }
    else if (node.nodeType === 'host') {
        return node.instance;
    }
    else if (node.rendered.length > 0) {
        for (const child of node.rendered) {
            const childHostNode = nodeToHostNode(child);
            if (childHostNode) {
                return childHostNode;
            }
        }
    }
    return null;
}
exports.nodeToHostNode = nodeToHostNode;
// Copied from enzyme-adapter-utils. We don't include that package because it depends on React
const nativeToReactEventMap = {
    compositionend: 'compositionEnd',
    compositionstart: 'compositionStart',
    compositionupdate: 'compositionUpdate',
    keydown: 'keyDown',
    keyup: 'keyUp',
    keypress: 'keyPress',
    contextmenu: 'contextMenu',
    dblclick: 'doubleClick',
    doubleclick: 'doubleClick',
    dragend: 'dragEnd',
    dragenter: 'dragEnter',
    dragexist: 'dragExit',
    dragleave: 'dragLeave',
    dragover: 'dragOver',
    dragstart: 'dragStart',
    mousedown: 'mouseDown',
    mousemove: 'mouseMove',
    mouseout: 'mouseOut',
    mouseover: 'mouseOver',
    mouseup: 'mouseUp',
    touchcancel: 'touchCancel',
    touchend: 'touchEnd',
    touchmove: 'touchMove',
    touchstart: 'touchStart',
    canplay: 'canPlay',
    canplaythrough: 'canPlayThrough',
    durationchange: 'durationChange',
    loadeddata: 'loadedData',
    loadedmetadata: 'loadedMetadata',
    loadstart: 'loadStart',
    ratechange: 'rateChange',
    timeupdate: 'timeUpdate',
    volumechange: 'volumeChange',
    beforeinput: 'beforeInput',
    mouseenter: 'mouseEnter',
    mouseleave: 'mouseLeave',
    transitionend: 'transitionEnd',
    animationstart: 'animationStart',
    animationiteration: 'animationIteration',
    animationend: 'animationEnd',
    pointerdown: 'pointerDown',
    pointermove: 'pointerMove',
    pointerup: 'pointerUp',
    pointercancel: 'pointerCancel',
    gotpointercapture: 'gotPointerCapture',
    lostpointercapture: 'lostPointerCapture',
    pointerenter: 'pointerEnter',
    pointerleave: 'pointerLeave',
    pointerover: 'pointerOver',
    pointerout: 'pointerOut',
    auxclick: 'auxClick',
};
function mapNativeEventNames(event) {
    return nativeToReactEventMap[event] || event;
}
exports.mapNativeEventNames = mapNativeEventNames;
// 'click' => 'onClick'
// 'mouseEnter' => 'onMouseEnter'
function propFromEvent(event) {
    const nativeEvent = mapNativeEventNames(event);
    return `on${nativeEvent[0].toUpperCase()}${nativeEvent.slice(1)}`;
}
exports.propFromEvent = propFromEvent;
