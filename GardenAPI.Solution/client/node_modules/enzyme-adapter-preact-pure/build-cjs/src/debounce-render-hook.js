"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flushRenders = exports.installHook = void 0;
const preact_1 = require("preact");
let hookInstalled = false;
const pendingCallbacks = new Set();
/**
 * Default implementation of debounced rendering, taken from Preact's
 * `enqueueRender` implementation.
 */
function defer(callback) {
    Promise.resolve().then(callback);
}
/**
 * Install an `options.debounceRendering` hook that tracks any debounced
 * renders scheduled by Preact, eg. due to a `setState` call.
 *
 * Scheduled renders will automatically flush in the next microtask as normal,
 * but can be manually flushed using `flushRenders`.
 */
function installHook() {
    if (hookInstalled) {
        return;
    }
    const origDebounce = preact_1.options.debounceRendering || defer;
    function trackPendingRender(callback) {
        pendingCallbacks.add(callback);
        origDebounce.call(null, callback);
    }
    preact_1.options.debounceRendering = trackPendingRender;
    hookInstalled = true;
}
exports.installHook = installHook;
/**
 * Synchronously perform any debounced renders that were scheduled by Preact
 * using `options.debounceRendering`.
 */
function flushRenders() {
    pendingCallbacks.forEach(cb => {
        cb();
    });
    pendingCallbacks.clear();
}
exports.flushRenders = flushRenders;
